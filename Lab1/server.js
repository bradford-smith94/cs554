/* Bradford Smith (bsmith8)
 * CS 554 Lab 1 server.js
 * 09/07/2017
 */

var express = require('express');
var bodyParser = require('body-parser');
var data = require('./data.js');

var app = express();

app.use(bodyParser.json()); //for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); //for parsing application/x-www-urlencoded

/* === middlewares ========================================================= */

/**
 * Log all request bodies, as well as the route they are requesting, and the
 * HTTP verb they are using.
 */
app.use(function(request, response, next) {
    console.log("Received HTTP " + request.method + " request for: " +
        request.originalUrl + " with body: " + JSON.stringify(request.body));
    next();
});

/**
 * Keep track of how many times a particular URL has been requested, updating
 * and logging with each request.
 */
var UrlCount = {}
app.use(function(request, response, next) {
    if (UrlCount[request.originalUrl]) {
        UrlCount[request.originalUrl]++;
    } else {
        UrlCount[request.originalUrl] = 1;
    }
    console.log("That's " + UrlCount[request.originalUrl] + " request(s) for: " + request.originalUrl);
    next();
});

/* === routes begin here =================================================== */

/**
 * GET /api/tasks
 *
 * Shows a list of tasks. By default, it will show the first 20 tasks in the
 * collection. If a querystring variable `?skip=n` is provided, you will skip the
 * first `n` tasks. If a querystring variable `?take=y` is provided, it will
 * show `y` number of results. By default the route will show 20 tasks; at most,
 * it will show 100 tasks.
 */
app.get("/api/tasks", function (request, response) {
    data.getAllTodos().then(function(todoList) {
        let start = 0;
        let end = 20;
        if (request.query.skip) {
            start = request.query.skip
        }
        if (request.query.take) {
            if (request.query.take > 100) {
                end = 100;
            } else {
                end = request.query.take;
            }
        }
        response.json(todoList.slice(start).slice(0, end));
    });
});

/**
 * GET /api/tasks/:id
 *
 * Shows the task with the supplied ID.
 */
app.get("/api/tasks/:id", function (request, response) {
    data.getTodo(request.params.id).then(function(todo) {
        response.json(todo);
    }, function(errorMessage) {
        response.status(500).json({ error: errorMessage });
    });
});

/**
 * POST /api/tasks
 *
 * Creates a task with the supplied detail and returns the created object; fails
 * request if not all details are supplied.
 */
app.post("/api/tasks", function (request, response) {
    todo = request.body;
    data.createTodo(todo.title, todo.description, todo.hoursEstimated).then(function(newTodo) {
        response.json(newTodo);
    }, function(errorMessage) {
        response.status(500).json({ error: errorMessage });
    });
});

/**
 * PUT /api/tasks/:id
 *
 * Updates the task with the supplied ID and returns the new task object;
 * **task**: PUT calls must provide all details of the new state of the object!
 * **Note** you cannot manipulate comments in this route!
 */
app.put("/api/tasks/:id", function (request, response) {
    todo = request.body;
    data.updateTodo(request.params.id, todo.title, todo.description, todo.hoursEstimated, todo.completed).then(function(updatedTodo) {
        response.json(updatedTodo);
    }, function(errorMessage) {
        response.status(500).json({ error: errorMessage });
    });
});

/**
 * PATCH /api/tasks/:id
 *
 * Updates the task with the supplied ID and returns the new task object;
 * **task**: PATCH calls only provide deltas of the value to update! **Note**
 * you cannot manipulate comments in this route!
 */
app.patch("/api/tasks/:id", function (request, response) {
    todo = request.body;
    data.updateTodoPartial(request.params.id, todo.title, todo.description, todo.hoursEstimated, todo.completed).then(function(updatedTodo) {
        response.json(updatedTodo);
    }, function(errorMessage) {
        response.status(500).json({ error: errorMessage });
    });
});

/**
 * POST /api/tasks/:id/comments
 *
 * Adds a new comment to the task; ids must be generated by the server, and not
 * supplied.
 */
app.post("/api/tasks/:id/comments", function (request, response) {
    data.createComment(request.params.id, request.body.name, request.body.comment).then(function(updatedTodo) {
        response.json(updatedTodo);
    }, function(errorMessage) {
        response.status(500).json({ error: errorMessage });
    });
});

/**
 * DELETE /api/tasks/:taskId/:commentId
 *
 * Deletes the comment with an id of `commentId` on the task with an id of
 * `taskId`.
 */
app.delete("/api/tasks/:taskId/:commentId", function (request, response) {
    data.deleteComment(request.params.taskId, request.params.commentId).then(function() {
        response.json({ success: true });
    }, function(errorMessage) {
        response.status(500).json({ error: errorMessage });
    });
});

/**
 * Catch anything else and give a 404
 */
app.use("*", function (request, response) {
    response.status(404).json({ error: "Not found" });
});

app.listen(3000, function() {
    console.log("Server is now listening on port 3000.");
});
